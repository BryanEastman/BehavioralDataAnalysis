check()
library(devtools)
use_r("hello")
load_all()
warnings()
check()
use_mit_license()
check()
check()
devtools::document()
check()
check()
usethis::use_testthat()
use_package("stats")
use_package("dplyr")
check()
use_pipe()
load_all()
df1 <- data.frame(id = 1:6, x = c(1, 1.5, 5, 5.5, 10, 10.5), y = c(1, 1.5, 5, 5.5, 10, 10.5))
pairing(df1, 'id')
use_test('pairing')
pairs <- pairing(df1)
pairs <- pairing(df1, 'id')
pairs == list(c(2,1), c(4, 3), c(6,5))
pairs == list(list(2,1), list(4, 3), list(6,5))
pairs2 = list(list(2,1), list(4, 3), list(6,5))
pairs[0]
pairs[1]
pairs2[1]
pairs2 = list(c(2,1), c(4, 3), c(6,5))
pairs2 = list(c(2L,1L), c(4L, 3L), c(6L,5L))
pairs == pairs2
pairs[1] == pairs2[1]
pairs[1][1] == pairs2[1][1]
identical(pairs, pairs2)
expect_identical(pairs, pairs2)
expect_identical(pairing(df1), list(c(2L,1L), c(4L, 3L), c(6L,5L)))
expect_identical(pairing(df1, 'id'), list(c(2L,1L), c(4L, 3L), c(6L,5L)))
t <- expect_identical(pairing(df1, 'id'), list(c(2L,1L), c(4L, 3L), c(6L,5L)))
testthat::test_file('test-pairing.R')
devtools::load_all()
testthat::test_file('test-pairing.R')
check()
check()
check()
document()
use_devtools()
devtools::dev_sitrep()
devtools::install_dev_deps()
devtools::dev_sitrep()
devtools::install_dev_deps()
install.packages(c("arrow", "bit", "broom", "bslib", "cli", "digest", "eha", "gert", "Hmisc", "htmltools", "htmlwidgets", "httpuv", "insight", "jpeg", "jtools", "openssl", "pkgbuild", "pkgdown", "png", "purrr", "rbibutils", "rmarkdown", "sass", "shiny", "tinytex", "vctrs", "whisker"))
install.packages(c("arrow", "bit", "broom", "bslib", "cli", "digest", "eha", "gert", "Hmisc", "htmltools", "htmlwidgets", "httpuv", "insight", "jpeg", "jtools", "openssl", "pkgbuild", "pkgdown", "png", "purrr", "rbibutils", "rmarkdown", "sass", "shiny", "tinytex", "vctrs", "whisker"))
install.packages(c("arrow", "bit", "broom", "bslib", "cli", "digest", "eha", "gert", "Hmisc", "htmltools", "htmlwidgets", "httpuv", "insight", "jpeg", "jtools", "openssl", "pkgbuild", "pkgdown", "png", "purrr", "rbibutils", "rmarkdown", "sass", "shiny", "tinytex", "vctrs", "whisker"))
df <- df1
df <- df %>% mutate(cat = c('A', 'A', 'B', 'C', 'A', 'B'))
library(dplyr)
df <- df %>% mutate(cat = c('A', 'A', 'B', 'C', 'A', 'B'))
cat_vars <- select_if(df, is.character) %>%
bind_cols(select_if(df, is.factor))
normalized_cat_cars <- data.frame()
id <- 'id'
N <- nrow(df)
# Extracting the matching variables for distance measurement
matching_vars <- df[, !names(df) %in% id]
#Handling numeric variables
normalized_num_vars <- data.frame()
if(any(sapply(matching_vars, class)=='numeric')){
num_vars <- matching_vars %>%
select_if(function(x) is.numeric(x)|is.integer(x))
#Normalizing numeric variables
normalized_num_vars <- num_vars %>%
dplyr::mutate(dplyr::across(.fns = min_max_norm))
} else {warning("The data has no numeric variables. Results may be unstable.")}
library(scales)
#Handling numeric variables
normalized_num_vars <- data.frame()
if(any(sapply(matching_vars, class)=='numeric')){
num_vars <- matching_vars %>%
select_if(function(x) is.numeric(x)|is.integer(x))
#Normalizing numeric variables
normalized_num_vars <- num_vars %>%
dplyr::mutate(dplyr::across(.fns = rescale))
} else {warning("The data has no numeric variables. Results may be unstable.")}
#Handling categorical variables
normalized_cat_vars <- data.frame()
if(any(sapply(matching_vars, class)=='factor'|sapply(matching_vars, class)=='character')){
cat_vars <- matching_vars %>%
select_if(is.factor)
#One-hot encoding categorical variables
normalized_cat_vars <- data.frame(predict(dummyVars(" ~.", data=cat_vars),
newdata = cat_vars))
}
library(caret)
#Handling categorical variables
normalized_cat_vars <- data.frame()
if(any(sapply(matching_vars, class)=='factor'|sapply(matching_vars, class)=='character')){
cat_vars <- matching_vars %>%
select_if(is.factor)
#One-hot encoding categorical variables
normalized_cat_vars <- data.frame(predict(dummyVars(" ~.", data=cat_vars),
newdata = cat_vars))
}
#Handling numeric variables
normalized_num_vars <- data.frame()
if(any(sapply(matching_vars, class)=='numeric')){
num_vars <- matching_vars %>%
select_if(function(x) is.numeric(x)|is.integer(x))
#Normalizing numeric variables
normalized_num_vars <- num_vars %>%
dplyr::mutate(dplyr::across(.fns = rescale))
} else {warning("The data has no numeric variables. Results may be unstable.")}
#Handling categorical variables
normalized_cat_vars <- data.frame()
if(any(sapply(matching_vars, class)=='factor'|sapply(matching_vars, class)=='character')){
cat_vars <- matching_vars %>%
select_if(function(x) is.factor(x)|is.character(x))
#One-hot encoding categorical variables
normalized_cat_vars <- data.frame(predict(dummyVars(" ~.", data=cat_vars),
newdata = cat_vars))
}
normalized_vars <- normalized_num_vars %>% cbind(normalized_cat_vars)
devtools::load_all()
testthat('pairing works on numeric data')
test_that('pairing works on numeric data')
?tests_that
?test_that
use_package('caret')
library(roxygen2)
library(devtools)
use_package('caret')
use_package("scales")
load_all()
pairing(df1, 'id')
#' Create a stratified assignment (aka. pair matching)
#'
#' @param df data to use
#' @param id column(s) used for identification
#' @param n.groups number of groups
#' @return a list of pairs, each having n.groups elements
#' @examples
#' df1 <- data.frame(
#' id = 1:6,
#' x = c(1, 1.5, 5, 5.5, 10, 10.5),
#' y = c(1, 1.5, 5, 5.5, 10, 10.5))
#' pairing(df1, 'id')
#' @export
pairing <- function(df, id, n.groups = 2){
N <- nrow(df)
# Extracting the matching variables for distance measurement
matching_vars <- df[, !names(df) %in% id]
#Handling numeric variables
normalized_vars <- data.frame(nrow(matching_vars))
if(any(sapply(matching_vars, class)=='numeric')){
num_vars <- matching_vars %>%
dplyr::select_if(function(x) is.numeric(x)|is.integer(x))
#Normalizing numeric variables
normalized_vars <- num_vars %>%
dplyr::mutate(dplyr::across(.fns = scales::rescale))
} else {warning("The data has no numeric variables. Results may be unstable.")}
#Handling categorical variables
if(any(sapply(matching_vars, class)=='factor'|sapply(matching_vars, class)=='character')){
cat_vars <- matching_vars %>%
dplyr::select_if(function(x) is.factor(x)|is.character(x))
#One-hot encoding categorical variables
normalized_cat_vars <- data.frame(predict(caret::dummyVars(" ~.", data=cat_vars),
newdata = cat_vars))
normalized_vars <- normalized_vars %>% cbind(normalized_cat_vars)
}
# Setting parameters for the matching
pairs_lst_lim <- floor(N/n.groups)
nb_matches_needed <- n.groups - 1 # Number of matches we want to find for each row
#Calculating distance matrix
d_mat <- matching_vars %>%
stats::dist(method = 'euclidean', diag = TRUE, upper = TRUE) %>%
as.matrix()
diag(d_mat) <- N + 1
available <- 1:N
pairs_lst <- list()
# Apply argpartsort to each column until enough matches have been found
for(c in 1:N){ # Iterating through the columns
if(length(pairs_lst) == pairs_lst_lim) { break } # Exiting the loop if we have enough pairs already
if(!(c %in% available)){ next } # Going to next iteration of the loop if the subject c is not available anymore
for(search_lim in nb_matches_needed:N){
closest_candidates <- argpartsort(d_mat[,c], search_lim)
matches <- intersect(available, closest_candidates)
if(length(matches) == nb_matches_needed){
pair <- list(append(matches, c)) # Adding the subject c to its list of matches to form a pair
pairs_lst <- append(pairs_lst, pair)
available <- setdiff(available, unlist(pair))
break
} else if(length(matches) > nb_matches_needed){
# Resolving ties
}
# Otherwise, redo the loop for search_lim += 1
}
}
return(pairs_lst)
}
### segment of code to put in a different function ###
# Assigning experimental groups to the matched pairs
# N_pairs <- length(matches_lst)
# exp_grps <- lapply(1:N_pairs, function(x) list(0,1))
# exp_grps <- lapply(exp_grps, function(x) sample(x))
# exp_grps <- unlist(exp_grps)
# matches_lst <- unlist(matches_lst)
#
# pairs_df <- tibble(
#   id = matches_lst,
#   grp = exp_grps
# )
# pairs_df <- pairs_df[order(pairs_df$id),]
##### Auxiliary functions #####
argpartsort <- function(vec, n){
# Returns the indices of the n smallest values
sorted <- sort(vec, n = n)
max_sorted <- max(sorted[1:n])
indices <- which(vec <= max_sorted)
return(indices)
}
# Normalizing all the numeric vectors in matching_vars
min_max_norm <- function(x) {
(x - min(x)) / (max(x) - min(x))
}
pairing(df1, 'id')
load_all()
rm(list = c("pairing"))
load_all()
update.packages()
remove.packages('cli')
install.packages('cli')
install.packages("cli")
update.packages()
library(devtools)
df1 <- data.frame(id = 1:6,
x = c(1, 1.5, 5, 5.5, 10, 10.5),
y = c(1, 1.5, 5, 5.5, 10, 10.5),
z = c('A', 'A', 'B', 'B', 'C', 'C'))
df = df1
id <- 'id'
# Extracting the matching variables for distance measurement
matching_vars <- df[, !names(df) %in% id]
#Handling numeric variables
normalized_vars <- data.frame(nrow(matching_vars))
if(any(sapply(matching_vars, class)=='numeric')){
num_vars <- matching_vars %>%
dplyr::select_if(function(x) is.numeric(x)|is.integer(x))
#Normalizing numeric variables
normalized_vars <- num_vars %>%
dplyr::mutate(dplyr::across(.fns = scales::rescale))
} else {warning("The data has no numeric variables. Results may be unstable.")}
library(dplyr)
#Handling numeric variables
normalized_vars <- data.frame(nrow(matching_vars))
if(any(sapply(matching_vars, class)=='numeric')){
num_vars <- matching_vars %>%
dplyr::select_if(function(x) is.numeric(x)|is.integer(x))
#Normalizing numeric variables
normalized_vars <- num_vars %>%
dplyr::mutate(dplyr::across(.fns = scales::rescale))
} else {warning("The data has no numeric variables. Results may be unstable.")}
model.matrix(~., data=df1)
cat_vars <- matching_vars %>%
dplyr::select_if(function(x) is.factor(x)|is.character(x)) %>%
dplyr::mutate(dplyr::across(.fns = as.factor))
#One-hot encoding categorical variables
normalized_cat_vars <- model.matrix(cat_vars)
normalized_cat_vars <- model.matrix(~., data = cat_vars)
cat_vars <- matching_vars %>%
dplyr::select_if(function(x) is.factor(x)|is.ch
#One-hot encoding categorical variables
normalized_cat_vars <- as.data.frame(model.matrix(~., data = cat_vars))
normalized_cat_vars <- as.data.frame(model.matrix( ~., data = cat_vars))
normalized_cat_vars <- as.data.frame(model.matrix( ~.-1, data = cat_vars))
normalized_vars <- normalized_vars %>% cbind(normalized_cat_vars)
load_all()
df1 <- data.frame(id = 1:6,
x = c(1, 1.5, 5, 5.5, 10, 10.5),
y = c(1, 1.5, 5, 5.5, 10, 10.5),
z = c('A', 'A', 'B', 'B', 'C', 'C'))
pairing(df1, 'id')
load_all()
check()
check()
check()
use_r('pairing')
0:2
list(0:2)
list(0,1)
df = df1
id = 'id'
n.groups = 2
# Generating the matched pairs
pairs_list <- pairing(df, id = id, n.groups = n.groups)
# Assigning experimental groups to the matched pairs
N_pairs <- length(pairs_lst)
N_pairs <- length(pairs_list)
exp_grps <- lapply(1:N_pairs, function(x) list(0,1))
assgnmt <- lapply(1:N_pairs, function(x) list(0,1))
assgnmt <- lapply(assgnmt, function(x) sample(x))
assgnmt <- unlist(assgnmt)
pairs_list <- unlist(pairs_list)
pairs_df <- tibble(
id = matches_lst,
grp = assgnmt
)
pairs_df <- data.frame(
id = matches_lst,
grp = assgnmt
)
pairs_df <- data.frame(
id = pairs_list,
grp = assgnmt
)
pairs_df <- pairs_df[order(pairs_df$id),]
use_test()
df_out <- df %>% merge(df, pairs_df, by='id')
df_out <- merge(df, pairs_df, by='id')
View(df_out)
df_out[1:2, 'grp']
sum(df_out[1:2, 'grp'])
load_all()
test_that("stratified assignment works on numeric data", {
df1 <- data.frame(id = 1:6, x = c(1, 1.5, 5, 5.5, 10, 10.5), y = c(1, 1.5, 5, 5.5, 10, 10.5))
strat_df <- strat_assign(df1, id = 'id')
expect_equal(sum(strat_df[1:2, 'grp']), 1)
expect_equal(sum(strat_df[3:4, 'grp']), 1)
expect_equal(sum(strat_df[5:6, 'grp']), 1)
})
check()
load_all()
check()
test_that("stratified assignment works when the number of rows isn't divisible by the number of groups", {
df1 <- data.frame(id = 1:7,
x = c(1, 1.5, 5, 5.5, 10, 10.5, 20),
y = c(1, 1.5, 5, 5.5, 10, 10.5, 20))
strat_df <- strat_assign(df1, id = 'id')
expect_equal(sum(strat_df[1:2, 'grp']), 1)
expect_equal(sum(strat_df[3:4, 'grp']), 1)
expect_equal(sum(strat_df[5:6, 'grp']), 1)
})
test_that("pairing works when the number of rows isn't divisible by the number of groups", {
df1 <- data.frame(id = 1:7,
x = c(1, 1.5, 5, 5.5, 10, 10.5, 200),
y = c(1, 1.5, 5, 5.5, 10, 10.5, 200))
expect_identical(pairing(df1, 'id'), list(c(2L,1L), c(4L, 3L), c(6L,5L)))
})
document()
df0 <- data.frame(id = 1:6, x = c(1, 1.5, 5, 5.5, 10, 10.5), y = c(1, 1.5, 5, 5.5, 10, 10.5))
usethis::use_data(df0)
usethis::use_data(df1)
load_all()
check()
?na.omit()
document()
df_char <- df1
usethis::use_data(df_char)
usethis::use_data(df_char, overwrite = TRUE)
df_num <- df0
usethis::use_data(df_num, overwrite = TRUE)
document()
usethis::use_data(df_char, overwrite = TRUE)
document()
document()
document()
load_all()
load_all()
df_na <- data.frame(
id = 1:6,
x = c(1, 1.5, NA, 5.5, 10, 10.5),
y = c(1, 1.5, 5, 5.5, NA, 10.5))
View(df_na)
use_data(df_na)
?expect_error
load_all()
test_that("pairing yields an error when data contains NA values", {
expect_error(pairing(df_na, 'id'), "please address NA values before using this function")
})
load_all()
test_that("pairing yields an error when data contains NA values", {
expect_error(pairing(df_na, 'id'), "please address NA values before using this function")
})
test_that("pairing yields an error when data is empty", {
expect_error(pairing(data.frame(2L), 'id'), "the data provided is empty")
})
ncol(df_na)
load_all()
test_that("pairing yields an error when data is empty", {
expect_error(pairing(data.frame(2L), 'id'), "the data provided is empty")
})
df0 <- data.frame(3L)
df0 <- data.frame(3)
df0 <- data.frame()
test_that("pairing yields an error when data is empty", {
expect_error(pairing(data.frame(), 'id'), "the data provided is empty")
})
load_all()
document()
document()
load_all()
load_all()
document()
check()
install()
data(mpg)
